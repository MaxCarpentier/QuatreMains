1. ÉNONCÉ :
Quatre Mains (''super-batterie'' répondant au jeu de l'interprète en temps réel.)

1.1 DESCRIPTION :
Élaboré dans le cadre d'une démarche de plus grande envergure visant le développement d'outils pour la performance interactive avec des instruments de musique robotisés, le programme Quatre Mains (pour percussions) permettra à l'utilisateur de jouer sur une ''super-batterie'' augmentée interagissant avec lui en temps réel.
Le système sera doté d'instruments de percussion surmontés de micros contacts ainsi que d'un contrôleur tactile ROLI Blocks sur lesquels l'utilisateur pourra jouer de la batterie, en plus de posséder un générateur de sons percussifs de synthèse ainsi qu'un dispositif de solénoïdes Polyend PercPro en vue de faire jouer des percussions (réelles et/ou virtuelles) en réponse au jeu de l'interprète.
Le tout prendra la forme d'un patch MAX/MSP autonome pouvant être utilisé dans une optique de comprovisation instrumentale.

2. ANALYSE DES BESOINS :
Section d'entrée :
Les attaques jouées sur les percussions par l'utilisateur devront pouvoir être communiquées au programme sous la forme de ''notes'' (listes comprenant l'instrument joué et la ''vélocité'') qui seront par la suite utilisées dans les différents processus pour permettre aux solénoïdes placés sur les percussions de ''répondre'' en temps réel au jeu de l'instrumentiste.
Les attaques seront captées à partir de micros contacts posés sur les percussions et donc un système de détection des transitoires d'attaques et d'analyse de la ''vélocité'' jouée à partir du signal audio entrant devra être élaboré.
Une chaîne de traitement audionumérique du signal d'entrée provenant des microphones devra être élaborée pour optimiser celui-ci en vue de la détection des transitoires d'attaque (filtrage, porte de bruit etc.)
Après quelques tests, je réaliserai le potentiel relativement limité de n'utiliser que des micros contacts posés sur des percussions comme entrée et déciderai donc d'opter pour l'ajout d'autres formats d'entrée à l'aide du contrôleur tactile ROLI BLOCKS.
Un système permettant de récupérer l'information de touché sur le contrôleur ROLI Blocks et de la traduire en format ''notes'' devra donc être élaboré, il pourra s'agir de ''pads'' sur lesquels l'utilisateur peut taper avec ses doigts ou encore de surfaces utilisant l'information de touché continu (position du doigt en X, Y et pression) pour générer des ''notes''.
Récupération de données sur le jeu de l'instrumentiste :
Un système devra être élaboré pour permettre de récupérer diverses informations sur le jeu de l'instrumentiste (tempo moyen joué, subdivision rythmique adoptée (binaire, ternaire etc.), intervalle de temps entre les attaques, compte des ''notes'', temps écoulé depuis le début d'une performance etc.) qui serviront à faire évoluer les différents processus, soit en adaptant le comportement des modules en temps réel à ces informations, soit en les utilisant pour effectuer des ''bifurcations'' entre les différents états possibles du programme (ex.: lorsque l'instrumentiste a joué x notes, le programme passe à un certain état (préréglage) / si celui-ci joue plus rapidement que x BPM, le programme passe à un autre état (préréglage) etc.)
Modules de transformation :
Les ''notes'' obtenues grâce à la section d'entrée devront pouvoir être envoyées à divers ''modules'' de transformation de listes qui permettront de faire jouer les solénoïdes en cohérence avec ce qui est joué réellement par l'instrumentiste.
Ces modules pourront prendre la forme de transformations simples (ex.: écho récursif avec temps de délai variable et ''freeze'', enregistrement et manipulation de boucles, reproduction du jeu de l'instrumentiste par utilisation de chaînes de Markov ou encore d'histogrammes etc.)
Ces modules devront être pensés pour fonctionner de manière autonome et modulaire pour que chacun d'entre eux puisse être ''encapsulé'' et dupliqué à volonté par la suite pour plus de flexibilité et pour permettre des comportements complexes par l'agencement de différents modules entre eux. Cela permettra aussi de réutiliser les modules dans le cadre de projets futurs.
Un système de matrice permettant d'envoyer la sortie de n'importe quel module en entrée de n'importe quel autre devra être élaboré pour permettre d'obtenir rapidement des comportements complexes à partir des composantes simples que sont les modules de base tout en favorisant l'expérimentation et la découverte des possibilités ''cachées'' dans le programme.
Un module de quantification rythmique devra aussi être élaboré pour contraindre la sortie des modules à une certaine rythmique si désiré.
Section de sortie :
La sortie des différents modules devra pouvoir être envoyée aux solénoïdes pour les faire jouer sur les percussions.
Pour ce faire, les listes devront être formatées en notes MIDI correspondantes à celles attendues par le dispositif Polyend PercPro.
Des options permettant d'ajuster les notes sortantes devront être ajoutées pour que le système réagisse de manière naturelle (courbe de transfert des vélocités MIDI, ''humanizer'' à l'aide de variations rythmiques et dynamiques aléatoires etc.)
Après quelques tests, je réaliserai qu'il serait intéressant d'ajouter la possibilité d'envoyer aussi les notes en sortie vers des percussions de synthèses en plus des percussions acoustiques jouées par les solénoïdes pour décupler les possibilités. Il sera donc nécessaire d'ajouter au programme des générateurs de sons de percussions de synthèse (ex.: ''kick'', ''snare'', ''toms'', ''hi-hats'' etc.) avec contrôle sur la sonorité de chacun (volume, filtrage, longueur de la résonnance etc.) Les notes MIDI pourront être envoyées aux solénoïdes (percussions acoustiques) et/ou aux percussions de synthèses à l'intérieur même du programme.
Évolution dans le temps :
Un système permettant de sauvegarder des états du programme et de passer d'un état à un autre dans le temps devra être élaboré dans une optique performative.
Les différents états prendront la forme de préréglages qui seront sauvegardés et pourront être appelés dynamiquement par la suite.
Il faudra qu'il soit possible de passer directement d'un état à l'autre ou encore d'effectuer des passages graduels par interpolation entre différents préréglages (permettant des progressions fluides dans le temps.)
Le passage d'un état à un autre pourra être régit directement par un contrôle laissé à l'utilisateur ou encore automatisé grâce aux informations obtenues sur son jeu (voir section ''récupération de données sur le jeu de l'instrumentiste''.)
Interface de contrôle et communication avec l'utilisateur :
Pour pouvoir être utilisé par d'autres de manière relativement conviviale, le programme devra posséder une interface de contrôle graphique assez simple à utiliser pour effectuer la calibration, contrôler les divers processus etc.
Des messages simples devront pouvoir être affichés de manière dynamique pour sur cette interface donner de l'information à l'utilisateur sur ce qu'il peut faire, le guider dans sa découverte du programme etc.

3. ACQUISITION DES CONNAISSANCES :
Perc Pro :
-	Perc Pro Tutorial : https://www.youtube.com/watch?time_continue=81&v=N03I_rzmclM (démonstration de toutes les composantes du PercPro)
-	Perc Pro Drumming Machine, Get Started - Polyend (manuel d'utilisation et de mise en marche initiale)
Analyse du signal audio (détection d'attaques) :
-	Real-Time Audio Analysis Tools for Pd and MSP - Pucket, Apel, Zicarelli (entre autres présentation de l'objet bonk et de ses principes)
-	Notes du cours Algorithmie et Effets Audionumériques II, section Techniques d'analyse du signal audio, sous-section 5.1.2 ''détection des attaques''
Algorithmie :
-	Notes du cours Algorithmie et Effets Audionumériques II, section Algorithmie complexe I (principalement pour stochastique et chaînes de Markov)
-	Notes du cours Algorithmie et Effets Audionumériques II, section Algorithmie complexe II (principalement pour distributions aléatoires)
Chaines de Markov :
-	http://www.algorithmiccomposer.com/2010/05/algorithmic-composition-markov-chains.html (illustration de chaînes de Markov dans une optique de composition algorithmique dans MAX/MSP)
Tutoriels MAX/MSP : 
-	Data Structures and Probability - Working with histograms and lookup tables
-	Data Collections — Using databases
-	Timing — Scheduling events
-	Presentation Mode — Creating a presentation interface for a patcher
-	Controlling Data Flow — Routing messages
-	Designing Equations — Creating complex mathematical statements
-	Basics — Getting MIDI input and output
-	Note Management — Generating and managing note events
-	Parsing — Decoding and encoding MIDI streams
-	Basic Sequencing — Playing back MIDI sequence data
-	Advanced Sequencing — Recording and manipulating MIDI sequences
-	List Processing — Manipulation of lists of data
-	Pattr Basics — Introduction to state management
-	Autopattr Bindings — Advanced patcher storage
-	Envelope Following - Generating a control curve from a complex signal
-	Creating Polyphonic Abstractions - Using the poly~ object to manage multiple copies of an MSP patcher
-	Audio-rate sequencing - Using ramp generators for sample-accurate event triggering
Algorithmie pour percussions :
-	Patcher X.Groover dans les exemples de MAX/MSP (un rare exemple de ''drum machine algorithmique'')
Quantification rythmique en temps réel :
-	Patcher live-quantize dans les exemples de MAX/MSP (utilisation de l'objet ''onebang'' pour la quantification rythmique)
Sends/receives :
-	send-receive-hoard-#0 dans les patchers d'exemple de MAX/MSP (trucs pour pouvoir utiliser des sends et receives qui sont contraints à l'intérieur d'un sous-patch ou d'une instance de poly, pour éviter que les objets interfèrent entre eux!)
-	send-receive-hoard-#1 dans les patchers d'exemple de MAX/MSP (version plus avancée, montre comment utiliser les nombre de 1 à 9 en plus de 0)
-	send-receive-share (illustration de solutions permettant d'envoyer de l'information ''dans les deux sens'' sans pour autant causer de ''stack overflow'', utilisation de l'objet ''value'')
Microphones contact :
-	http://www.musicofsound.co.nz/blog/the-first-rule-of-contact-mic-club (billet de blog donnant une foule d'astuces pratiques sur l'utilisation concrète des micros contacts)
-	Patcher sensor-tamer dans les exemples de MAX/MSP (filtrage d'un signal en vue de l'optimiser pour en extraire des données, pourrait s'appliquer ou ne pas s'appliquer aux micros contacts)
ROLI Blocks :
-	BLOCKS_Launch (section de ressources et d'exemples installée avec le librairie de ROLI Blocks)
-	https://www.youtube.com/watch?v=uQDrtOYDxt8 (Tutoriel sur l'installation et la mise en marche d'un contrôleur ROLI Blocks pour l'utilisation avec MAX/MSP)
-	https://www.youtube.com/watch?v=2BsHYJ4lKdA (Tutoriel de base sur la création et l'utilisation d'objets ROLI Blocks)
-	https://www.youtube.com/watch?v=xnHnkzyi2v8 (Exemple de patch conçue pour le ROLI Blocks dans MAX/MSP : le FM Drum Synth)
-	https://www.youtube.com/watch?v=c3mmMIvvghQ (Conférence ADC 2016 où David Zicarelli présente la librairie d'objets ROLI Blocks pour MAX/MSP, ses utilisations possibles et son processus d'élaboration)
-	blocks.pad (explications de l'objet permettant d'interagir avec un ROLI Blocks)
-	blocks.multictrl (explications de l'objet permettant d'interagir avec le ROLI Multictrl attaché à un ROLI Blocks)
-	blocks.multitouch (explications de l'objet permettant de récupérer et utiliser les données de touché continu à partir du ROLI Blocks)
-	blocks.notemap (alternative pour générer des notes MIDI à partir du ROLI Blocks sans avoir à le faire ''à la mitaine'' à partir de blocks.multitouch, s'avère par contre beaucoup moins flexible...)
-	Patcher BLOCKS Looper (exemple illustrant les possibilités d'utilisation des composantes matérielles ROLI Blocks et des différents objets dans une application réelle)
Gestion de l'entrée et sortie audio dans MAX/MSP :
-	https://docs.cycling74.com/max5/tutorials/msp-tut/mspaudioio.html (pratique pour les considérations de latence, de drivers et de stabilité audio sous Windows...ça peut être franchement compliqué à faire fonctionner convenablement...)
Gestion de la latence dans MAX/MSP :
-	latency test dans les patchers d'exemple de MAX/MSP (permet de tester automatiquement la latence audio d'un système)
-	http://expressiveness.org/2012/12/04/midi-jitter (article discutant du ''MIDI Jitter'' qui peut faire varier constamment le temps de latence dans MAX/MSP, qui n'est pas constant d'une note à l'autre, donc peu d'utilité de gérer la latence de manière fixe en fonction de la valeur obtenue au test précédent)
-	Action-Sound Latency: Are Our Tools Fast Enough? - Andrew P. McPherson (article extrêmement instructif concernant les considérations de latence dans les systèmes musicaux interactifs, selon les chercheurs, la latence pour des instruments percussifs devrait se trouver sous la barre des 10ms et serait optimale sous les 4ms, au réglage de ''buffer size'' le plus bas et en utilisant le MIDI, MAX/MSP pourrait selon eux atteindre une performance de 5.1ms de latence avec par contre 1ms de jitter, ce qui rend le logiciel, même dans sa configuration optimale, moins performant qu'un percussionniste réel d'expérience) 
Comprovisation :
-	Agône : un outil adapté à une démarche de création en comprovisation électroacoustique - Jullian Hoff (exemple de démarche semblable en comprovisation, utilisant dans ce cas la guitare comme instrument de base)
-	https://jullianhoff.wordpress.com/hyperguitare-2/ (exemples vidéos de performances utilisant une guitare électrique augmentée pour piloter divers processus audio ex. : granulateur)

4. MODÈLE :
Quatre Mains (pour percussions) est un système de type ''analyse et récupération de données entrantes - transformations - génération de nouvelles données sortantes'' appliqué sur des listes représentant des notes.
L'étape d'analyse et de récupération de données sur le jeu de l'interprète permet tout d'abord de faire le pont entre l'instrumentiste et l'ordinateur, non seulement en transformant le signal provenant des micros contacts et du contrôleur tactile ROLI Blocks en listes représentant des notes et leurs vélocités respectives, mais aussi en récupérant une foule de données sur le jeu du percussionniste (comme le compte des notes depuis le début d'une performance donnée, l'intervalle de temps entre deux notes jouées, le tempo adopté par l'interprète, la subdivision rythmique choisie, le temps écoulé au sein d'une comprovisation etc.)
Les transformations, quant à elles, prennent la forme de manipulations effectuées sur les listes récupérées en entrée grâce à différents processus comme l'enregistrement et la modification de fragments de jeu, la répétition rythmique dans le temps de certaines notes, la reproduction approximative de séquences jouées par l'intermédiaire de chaînes de Markov ou encore d'histogrammes stockant les données sur le jeu de l'interprète etc. Ces transformations se voulant réactives, le comportement des différents modules de manipulation peut être modifié en fonction de l'analyse des données entrantes, soit en modifiant les paramètres des processus eux-mêmes ou encore en permettant de faire passer le programme d'un état à un autre.
La génération finale est l'étape permettant d'utiliser ces nouvelles listes transformées de manière musicale pour produire des sons par l'envoi de notes MIDI à un dispositif composé de solénoïdes Polyend PercPro (faisant jouer de vrais instruments de percussion) ou encore à une batterie virtuelle composée de sons de synthèse.

5. MÉTHODES:
Analyse et récupération de données sur le signal :
Une classe audio contiendra un détecteur de transitoires d'attaque permettant d'extraire du signal continu des micros contacts des attaques discrètes qui seront par la suite associées à un index correspondant à la percussion jouée ainsi qu'à une vélocité entre 1 et 127 en fonction du niveau d'amplitude détecté.
Pour optimiser la détection des attaques, une chaîne de traitements simples (filtrage et porte de bruit) sera implémentée en amont de la classe audio servant à la détection.
Pour permettre la détection de notes jouées sur le contrôleur ROLI Blocks, des surfaces réactives au touché seront définies sur celui-ci et chaque surface sera associée à une instance d'une classe permettant de transformer les informations détectées en listes (index de percussion, vélocité), soit de manière discrète et instantanée, soit en utilisant ces informations pour faire varier en temps réel les paramètres de plusieurs métronomes utilisés pour générer des listes.
Seront aussi encapsulées dans un sous-programme les informations pertinentes récupérées sur le jeu de l'instrumentiste par l'intermédiaire de divers compteurs et autres minuteurs, informations qui pourront être récupérées en sortie de ce sous-programme en vue d'être réutilisées par les différents processus.
Transformations :
Tous les modules de transformation seront conçus de manière à pouvoir être encapsulés dans des classes en vue de favoriser la duplication aisée de ceux-ci et leur agencement dans des configurations complexes.
Une classe contiendra un effet de délai récursif avec ''freeze'' pouvant être appliqué sur les listes lui étant envoyées en entrée. L'effet sera relié à une surface tactile définie sur le contrôleur ROLI Blocks, et lorsque l'utilisateur posera le doigt sur cette surface, le niveau de récursion appliqué passera à 100% (permettant l'effet de ''freeze'') et les valeurs de position et de pression du doigt seront utilisées pour faire varier les paramètres du délai. La position du doigt en Y permettra de faire varier le temps de délai entre la valeur initiale et le temps de délai minimal défini (valeurs données en argument de l'objet) alors que la pression sera utilisée pour définir la vélocité des notes dans la ligne de délai lorsque celui-ci est en mode ''freeze''.
Une classe contiendra un module permettant d'enregistrer et de manipuler des boucles en temps réel. Les notes en entrée de ce module seront associées à un index ainsi qu'à certaines informations les concernant (hauteur, vélocité, temps avant la prochaine note ''deltaT'' etc.) et seront par la suite stockées dans un espace mémoire. Il sera possible de faire jouer les boucles ainsi enregistrées en incrémentant un compteur associé aux indexes des notes à chaque ''deltaT''. En faisant varier les paramètres de ce compteur (minimum, maximum, sens du décompte, multiplicateur du ''deltaT'' etc.) il sera possible de modifier les boucles en temps réel. La hauteur de note ainsi que la vélocité pourront aussi être modifiées en temps réel par des additions et des soustractions effectuées sur les valeurs.
Une classe sera implémentée en vue de stocker dans des espaces mémoires dédiés des histogrammes permettant de savoir quelles sont les notes ayant été jouées le plus souvent, les vélocités les plus fréquentes ainsi que les valeurs de ''deltaT'' qui ressortent du jeu de l'interprète en incrémentant un compte individualisé pour chaque valeur possible de ces trois descripteurs. En utilisant ensuite le ''poids'' de chacune des valeurs possibles dans la génération de valeurs aléatoires, il sera possible de reproduire de manière approximative le jeu du percussionniste.
Une classe permettant de tirer profit de l'algorithme de Markov sera aussi mise en place en calculant cette fois-ci plutôt la probabilité du passage d'une valeur à une autre (et non la probabilité d'apparition d'une valeur en elle-même), ce qui aboutira à des simulations plus réalistes du jeu de l'interprète.
Un système de sauvegarde, de gestion et de rappel de préréglages sera aussi implémenté pour permettre de passer d'un état à l'autre du programme (des états différents impliquent des transformations différentes.) Chaque état du programme sauvegardé sera donc associé à un index en nombres entiers et il sera possible de rappeler un état par son index correspondant ou encore d'effectuer une interpolation entre différents états par l'utilisation de nombres décimaux. Des suites de préréglages pourront être sauvegardées et manipulées dans des fichiers textes, ce qui permettra de prévoir différentes performances et de les encapsuler indépendamment du programme lui-même.
Génération des données sortantes :
Dans un souci de musicalité, une classe permettant la quantification rythmique des notes en sortie du programme sera mise en place. Cette classe stockera, dans un petit espace mémoire, les notes qui devraient être jouées entre les subdivisions d'un tempo prédéfini et ne les laissera passer qu'au moment d'une subdivision du tempo. Il sera possible de définir une quantité de quantification rythmique qui aura pour effet de ne faire passer qu'un certain pourcentage des notes par l'objet de quantification.
De plus, des modules permettant d'ajouter une touche humaine au comportement du programme seront ajoutés. Une classe permettra d'appliquer un délai à la sortie des listes (délai d'une durée aléatoire entre 0ms et un temps maximal défini en argument), alors qu'une autre classe permettra des variations aléatoires de la vélocité en additionnant ou en soustrayant un nombre au hasard se trouvant à l'intérieur de limites définies encore une fois en argument.
Une ''fonction de transfert MIDI'' sera implémentée pour permettre à l'utilisateur d'ajuster précisément et de manière globale la réponse en sortie du système (une valeur X en entrée retournera une valeur Y prédéfinie en sortie.)
Des classes contenant chacune un instrument de percussion de synthèse construit à partir de composantes simples (ondes sonores de base, bruit blanc etc.) seront aussi ajoutées pour offrir plus de variété à l'interprète et lui permettre d'utiliser le système même s'il n'a pas accès au dispositif Polyend PercPro à un certain moment.
Une section de calibration en vue de l'envoi des notes au Polyend PercPro sera finalement implémentée, section prenant la forme d'une interface graphique simple permettant à l'utilisateur de faire la sélection de la sortie MIDI à utiliser, des notes précises à envoyer au dispositif etc.

6. IMPLÉMENTATION :
Environnement de programmation choisi :
-	MAX/MSP (puisque je développerai plusieurs dispositifs ''Quatre Mains'', je tenterai de m'en tenir à un même environnement pour tous ces dispositifs et un premier programme a déjà été développé pour piano mécanique Yamaha Disklavier dans MAX/MSP, la communication entre les 2 sera le cas échéant plus efficace, il sera possible de réutiliser et transférer des morceaux etc. + il existe une excellente librairie d'objets ROLI Blocks dans MAX/MSP et le support devrait être assuré pour longtemps puisque JUCE (qui est à la base de MAX/MSP) appartient maintenant à ROLI + un patch MAX/MSP est facile d'approche pour des utilisateurs qui ne sont pas familiers avec le programme, il est possible d'avoir des éléments graphiques intuitifs, un mode de ''Présentation'' convivial etc. + c'est un environnement de prototypage rapide et efficace + grande communauté de gens s'intéressant à l'algorithmie + possibilité d'adapter plus tard les outils développés pour une utilisation dans Ableton Live à l'aide de Max For Live.)
Section d'entrée :
-	mx.audiotrigger (détection d'attaque sur le signal audio provenant des micros contacts à l'aide de l'objet bonk~, la vélocité sortant de bonk~ est ramenée sur l'ambitus désiré grâce à une calibration où on détecte quelques fois la vélocité minimale moyenne et la vélocité maximale moyenne et où l'on peut contrôler l'exposant de la ''courbe de transfert'' des vélocités, l'objet quickthresh est utilisé pour éviter des détections d'attaque inutiles à l'intérieur d'un intervalle de temps spécifié.)
-	optimisation du signal entrant pour la détection (après des tests montrant les lacunes du système original, particulièrement avec les instruments ayant une résonnance assez longue, un système de filtrage multimode du signal d'entré a été ajouté pour permettre, à l'aide de l'objet biquad~, de centrer l'analyse des attaques sur la région spectrale qui nous intéresse en plus d'une porte de bruit mx.gate qui fût développée pour réduire la résonnance des percussions et ainsi éviter des ''fausses détections d'attaques'', cette porte de bruit est inspirée des exemples fournis par Cycling '74 dans le manuel de MAX/MSP.
-	Pads jouables ajoutés à la première scène du ROLI Blocks après des tests révélant les lacunes du système original, l'objet blocks.notemap étant très contraignant (on ne peut pas choisir la forme ou encore la grosseur du pad créé), j'ai développé un objet très simple mx.blocks_vel permettant de récupérer l'information de touché continu d'un objet blocks.multitouch du ROLI Blocks et d'en faire une ''vélocité'' en utilisant la valeur de pression (entre 0 et 1) au moment du début d'un contact avec le surface et en la ramenant sur l'ambitus des vélocités MIDI (1 à 127.)
Modules de transformation :
-	Module Multi-touch (module simple permettant de générer des notes à partir de l'information de touché continu récupérée d'un objet blocks.multitouch, le début et la fin d'un contact avec la surface sont utilisés pour démarrer et arrêter un métronome générant des notes, la position du doigt en Y est utilisée pour faire varier la vitesse du métronome entre un minimum et un maximum par l'intermédiaire de l'objet scale et la pression est utilisée pour contrôler la vélocité qui est elle aussi ramené à un ambitus désiré de 1 à 127 grâce à l'objet scale, le temps minimum et maximum entre les notes peut être modifié dynamiquement en fonction du tempo et un système simple de gestion de la polyphonie mx.polygestion a été ajouté pour permettre d'avoir plusieurs doigts sur une même surface en même temps.)
-	Module Feedback Freeze (module de délai simple avec récursion des notes entrantes à l'aide de l'objet pipe, un temps de délai initial et minimal peut être spécifié, puisqu'il est possible de ''freezer'' le délai en posant le doigt sur la surface du blocks.multitouch, ce qui fait passer le niveau de feedback à 100% instantanément, à ce moment a position en Y du doigt est utilisée pour faire varier le temps de délai de l'objet pipe entre la valeur initiale et la valeur minimale et la pression est utilisée pour faire varier la vélocité sortante, encore une fois l'objet scale est utilisé pour ramener dynamiquement toutes ces valeurs aux ambitus désirés, un temps de ''catch'' de 100ms a été ajouté après des tests pratiques révélant l'aspect non-naturel des sauts abruptes de valeurs.)
-	Module d'enregistrement et de manipulation de boucles (module permettant d'enregistrer une séquence de notes entrante en associant toutes les informations pour une note (hauteur, vélocité, temps avant la prochaine note) à un index obtenu grâce à un compteur et stockant toutes ces informations en format texte dans un objet coll en vue de refaire jouer la séquence grâce à un autre compteur lisant la collection ainsi obtenue par la suite, en modifiant la direction du compteur, il est possible de faire jouer la séquence à l'endroit, à l'envers ou en palindrome, des objets rslider permettant à l'utilisateur de spécifier un minimum et un maximum relatif pour modifier la longueur de la séquence d'un clic en envoyant ces valeurs au compteur et des modifications sur les notes elles-mêmes peuvent être apportées en additionnant ou en multipliant des nombres aux valeurs de hauteur, de vélocité et de temps entre les notes grâce aux boites à chiffres prévues à cet effet dans l'interface, finalement, un toggle permet de choisir si l'on veut que la boucle se ferme au moment d'arrêter la détection ou plutôt au début de la dernière note jouée.)
-	Module de chaînes de markov (module utilisant les objets anal et prob pour permettre de reproduire le jeu de l'instrumentiste à l'aide de chaînes de Markov de 1er ordre, après avoir testé une version utilisant des chaînes de Markov de 2e ordre, j'ai décidé d'opter pour la première puisqu'étant moins exacte, elle semblait plus naturelle (la seconde finissait souvent par se mettre à tourner en rond très rapidement...), le hauteur, la vélocité et le temps entre les notes sont utilisés, la précision du temps entre les notes est réduite à 50ms pour que les valeurs ne soient pas toutes différentes (encore une fois pour éviter que ça tourne en rond) et sont limitées entre 50ms et 3s. pour éviter des valeurs qui ne seraient pas naturelles, la toute première valeur enregistrée est utilisée dans chaque cas comme valeur à laquelle retourner s'il n'existe aucune transition possible.)
-	Module d'histogrammes stockés dans des tables (ce module garde en mémoire dans des tables des histogrammes obtenus grâce à l'objet histo pour la hauteur des notes, la vélocité ainsi que le temps entre les notes, en envoyant des bangs dans les tables ainsi obtenues, on obtient des valeurs au hasard parmi celles stockées tout en tenant compte des valeurs ayant été détectées plus ou moins souvent (plus la valeur en Y est élevée, plus il y a de chance que la valeur en X sorte), ce qui permet d'imiter le jeu de l'instrumentiste de manière plus approximative qu'avec les chaînes de Markov pour un résultat différent.)
Fonctionnement modulaire :
-	Encapsulation des modules au sein d'objets poly~ (pour faire la transition de mes objets initiaux à leurs versions pouvant être encapsulées dans un poly~, j'ai dû modifier tous les ''inlets'' et ''outlets'' pour des ''ins'' et ''outs'', ajouter #0 devant tous les ''sends'' et ''receives'' devant être individualisés d'une instance à l'autre et ajouter des objets thispoly~ dans les objets pour permettre d'associer chacune des notes sortantes d'une instance à l'instance en question, finalement, l'utilisation du message ''taget $1'' permet d'envoyer les valeurs des différents contrôles à l'instance voulue.)
-	Matrice de connexions entre les modules (plutôt que d'utiliser la matrice de base de MAX/MSP qui ne permet pas d'avoir des ''sous-cellules'', j'ai développé ma propre matrice qui permet non-seulement d'envoyer un module vers un autre, mais aussi d'envoyer une instance précise d'un module vers une instance précise d'une autre module ou de lui-même grâce à des objets radiogroups permettant d'obtenir des ''sous-cellules'', j'ai par la suite conçu l'objet mx.aiguillage_perc utilisant les valeurs des radiogroups pour envoyer les notes au bon endroit par l'intermédiaire d'un objet router visant le bon module et du message ''target'' correspondant à l'instance visée au sein de ce module.)
Gestion des composantes matérielles ROLI :
-	En plus d'utiliser le contrôleur ROLI Blocks en lui-même pour ses possibilités tactiles (pads, strips, surfaces sensibles à la pression etc.) j'ai décidé d'utiliser les boutons ainsi que la barre de leds du Bocks Multictrl comme interface de contrôle et de visualisation permettant à l'utilisateur d'avoir accès à plusieurs fonctions du programme sans pour autant avoir à utiliser l'ordinateur et la souris pour naviguer dans l'interface. Pour ce faire, j'ai configuré certains boutons pour fonctionner comme des toggles et d'autres comme de réels boutons, j'ai élaboré un système éteignant automatiquement certains toggles lorsque d'autres toggles sont allumés (pour éviter des conflits et rendre la vie de l'utilisateur aussi facile que possible), ainsi qu'une manière de n'envoyer certaines valeurs que lorsqu'on relâche un bouton. J'ai ensuite assigné chacun de ces boutons aux fonctions les plus utiles à avoir au bout des doigts et ait géré la barre de leds de manière à ce que ceux-ci s'allument ou s'éteignent de manière cohérente avec les actions posées par l'utilisateur (pour afficher, par exemple, la quantité de quantification rythmique appliquée ou encore le préréglage à sauvegarder.)
Système de gestion des préréglages :
-	États sauvegardés avec pattrstorage (système permettant de sauvegarder une suite de plusieurs états du patch dans un fichier json à l'aide des objets pattrstorage et autopattr, un fichier json peut contenir le déroulement d'une comprovisation ou d'une performance donnée et il est possible d'enregistrer autant de fichiers json que désiré, de les modifier à volonté et de les relire par la suite, ce qui rend le système très flexible.) 
-	Préréglages utilisateur (un processus simple a été mis en place pour permettre à l'utilisateur de sauvegarder jusqu'à 15 préréglages de son choix dans des espaces mémoire lui étant réservé au sein de l'objet pattrstorage, soit en maintenant enfoncé la touche correspondante sur le blocks.multictrl et en naviguant dans les espaces mémoire à l'aide des boutons + et - qui font se déplacer un compteur entre 1000 et 10015, lorsque la touche est relâchée, un objet select 0 envoie la valeur de compteur au pattrstorage, ce qui sauvegarde le préréglage, le même principe est utilisé avec une autre touche pour permettre de rappeler des préréglages utilisateurs et la barre de leds du blocks.multictrl a été gérée pour affichier visuellement la valeur du compteur concerné, permettant de savoir lequel des 15 presets on s'apprête à enregistrer ou encore à rappeler.)
Récupération d'informations sur le jeu :
-	Tap Tempo réactif (j'ai conçu l'objet mx.taptempo pour permettre de détecter un tempo joué par l'utilisateur en calculant, à l'aide d'un objet timer et d'une petite moyenne maison, l'intervalle de temps moyen entre les noires jouées ainsi que l'intervalle de temps moyen pour la plus petite subdivision jouée, ce qui permet de détecter avec une précision étonnante si l'utilisateur joue des croches, des triolets ou encore des double-croches, et ce sans que ce dernier ait besoin de jouer toutes les subdivisions et de manière 100% réactive, puisque tant que la détection est en cours, les valeurs de tempo et de subdivision sont mises à jour à chaque note jouée.)
-	mx.deltaverage (dans la même veine que l'objet précédent, les 2 objets mx.deltaverage v1 et v2 permettent de détecter le temps moyen entre les notes jouées, information permettant de faire varier les différents processus en fonction de la vitesse à laquelle le joueur joue, indépendamment du tempo pour plus de flexibilité et pour permettre de recevoir cette valeur même si le tap tempo n'est pas en marche.)
-	Autres informations (la note jouée, la vélocité, le compte des notes depuis le début, le temps entre les 2 dernières notes ainsi que le temps écoulé depuis le début sont autant d'informations que le programme utilise pour faire varier le processus en utilisant principalement des objets counter et clocker pour obtenir ces valeurs.)
Évolution temporelle et communication avec l'utilisateur :
-	Affichage dynamique de directives (pour guider l'utilisateur dans sa découverte du dispositif Quatre Mains, des directives simples sont stockées dans un objet coll et sont associées aux différents préréglages de manière à être affichées au bon moment, il s'agit donc en quelque sorte d'un tutoriel simple, mais il faut préciser que ce système de directives pourra dans le futur être utilisé dans le cadre de performances et de comprovisations plus complexes pour communiquer de l'information à l'instrumentiste.)
-	Forme/aiguillage/bifurcation (les informations recueillies dans le sous-patch ''forme'' sont utilisées pour faire évoluer les états du patch dans le temps, les valeurs récupérées en analysant le jeu de l'instrumentistes sont comparées à des ''valeurs de bifurcation'' stockées dans les préréglages, et lorsque le résultat d'une comparaison est positif, une progression vers un état différent du patch est amorcée, soit par saut direct à un préréglage prédéterminé, soit par interpolation sur un certain intervalle de temps entre l'état courant et l'état suivant par l'intermédiaire d'un objet line, les valeurs de bifurcations peuvent être absolues et fixes ou relatives et aléatoires en fonction de la valeur courante, les comparaisons peuvent être ==, !=, <= ou encore >= et il est possible de faire passer le compteur régissant l'évolution au prochain préréglage dans la suite ou encore à un préréglage précis par l'utilisation du message ''jam $1''
-	Mode de présentation (les principaux objets que l'utilisateur pourrait vouloir manipuler ont été ajoutés au ''mode de présentation'' du patch de manière à ce que l'instrumentiste puisse expérimenter rapidement et de manière conviviale avec le dispositif Quatre Mains sans avoir nécessairement à ouvrir le patch en lui-même, il s'agit donc en quelque sorte d'une interface graphique rudimentaire permettant d'avoir un accès direct aux principaux outils offerts.)
Section de sortie :
-	Quantification rythmique (les notes jouées entre deux subdivisions du tempo sont stockées dans une collection de ''notes_en_attentes'' en attendant la prochaine subdivision du tempo et à chaque réception d'un bang provenant de cette subdivision, l'objet coll est vidé de toutes les notes qui sont alors envoyées à la section de sortie en rythme, un système permettant de spécifier une quantité de quantification à appliquer a aussi été conçu : un slider envoie une valeur entre 0 et 100 au patcher ''jitter'' qui génère des nombres aléatoires entre 0 et 99 à chaque réception d'un bang provenant de la subdivision rythmique, si la valeur aléatoire est plus grande ou égale à celle du slider, les notes ne passent pas par mx.timequantize_v2 alors que si la valeur est plus petite, les notes passent par la quantification rythmique.)
-	''Humanizer'' (j'ai élaboré deux systèmes simples pour donner une touche un peu plus humaine au jeu du programme, soit mx.timedev qui applique un délai d'une durée aléatoire entre 0 et la valeur spécifiée en argument aux notes et mx.veldev qui applique une variation aléatoire dans un ambitus de plus ou moins la valeur donnée en argument à chaque vélocité entrante.)
-	''Fonction de transfert MIDI'' (un objet itable a été ajouté pour permettre à l'utilisateur de dessiner une ''fonction de transfert MIDI'' directement dans l'interface du patch en vue d'adapter les valeurs de vélocité sortante des différents modules à la réponse du dispositif Polyend PercPro dans une situation de la vie réelle, ce qui permet d'exagérer les écarts dynamiques, de les compresser etc.)
-	Batterie virtuelle de synthèse (les instruments de la batterie virtuelle de synthèse sont tirés de patches Max For Live fournis avec Ableton Live et n'utilisant que des objets ''de base'' de MAX/MSP, ce qui permet de ne pas ajouter de librairies additionnelles à la liste, somme toute plutôt courte, de prérequis pour faire fonctionner le projet...ce qui était assez important pour moi!)
-	Envoi de notes au dispositif Polyend PercPro (toutes les listes manipulées dans le programme ne sont pas de réelles notes MIDI, puisqu'elles ne contiennent que l'information de ''note-on'', ce qui permet d'éviter plusieurs considérations par rapport aux ''note-offs'', ainsi, le toute fin du programme utilise un objet makenote connecté à un noteout pour permettre d'envoyer de réelles notes MIDI au dispositif Polyend PercPro qui peut être sélectionné à l'aide de l'objet umenu, la note associée à chaque solénoïde peut par ailleurs être sélectionnée par l'utilisateur grâce à des boîtes à chiffres.)

7. TEST ET MAINTENANCE :
Section d'entrée :
-	La détection d'attaque s'est avérée moyennement efficace sur les instruments de percussion ayant une longue résonnance et donc un système d'optimisation du signal entrant (filtrage et porte de bruit) a été élaboré. De plus, l'objet quickthresh a été utilisé pour éviter la détection de ''fausses attaques'' tout de suite après qu'une ''vraie attaque'' ait été détectée. Suite à ces additions, le système s'est avéré très efficace pour détecter des attaques sur une foule de surfaces différentes, en autant que la calibration ait été effectuée avec attention.
-	Si l'on détecte les attaques sur une percussion et fait jouer cette même percussion par le Polyend PercPro, il y a des interférences (on capte l'attaque provenant du programme comme étant une attaque provenant de l'instrumentiste!) et c'est pourquoi il est important de faire la détection d'attaques sur des instruments différents de ceux sur lesquels on fait jouer les solénoïdes.
-	Pour avoir plus de possibilités (et permettre d'utiliser le système lorsque je n'ai pas accès au dispositif PercPro et aux micros contacts) j'ai décidé d'ajouter le contrôleur ROLI Blocks comme entrée (en créant des pads sur la surface, sur lesquels on peut jouer en tapant dessus) et une batterie virtuelle de synthèse (contenue à même MAX/MSP.) Cela permet d'augmenter encore plus cette ''super-batterie'' et de considérer tous les aspects faisant partie de l'arsenal du percussionniste moderne (''drum machines'', ''finger drumming pads etc.'') en évitant les limitations du système original.
-	L'objet blocks.notemap est très contraignant, l'utilité du ROLI Blocks est de pouvoir modifier à volonté les formes affichées sur la surface et les pads du blocks.notemap ne peuvent pas avoir la forme de notre choix. J'ai donc décidé de créer une alternative transformant l'information provenant d'une surface blocks.multitouch en vélocité MIDI, ce qui permet de modifier la forme à volonté!
Modules de transformation :
-	Module Multi-touch (lorsqu'on pose un deuxième doigt sur la surface avant d'avoir retiré le premier, on perd la note, c'est pourquoi j'ai élaboré un système de gestion de la polyphonie permettant d'avoir jusqu'à deux doigts simultanément sur la même surface, ''l'index'' de touché étant utilisé pour envoyer l'information à l'une ou l'autre des instances d'un objet poly~ encapsulant les mx.multitouch.)
-	Module Feedback Freeze (les sauts abruptes d'une valeur à une autre ne sont pas naturels et c'est pourquoi j'ai ajouté un temps de ''catch'', les valeurs en Y et en P passent par un objet line de 100ms qui ralenti l'évolution trop rapide des valeurs, de plus, un délai de 101ms a été ajouté au départ du ''freeze'' pour compenser pour ce temps de ''catch'')
-	Module d'enregistrement et de manipulation de boucles (le fait d'attendre que la détection soit terminée avant de fermer la boucle n'est pas toujours très pratique, j'ai donc décidé d'ajouter l'option de pouvoir choisir si l'on ''attendre le dernier deltaT'' avant de fermer la boucle ou plutôt fermer celle-ci directement à la dernière note pour éviter de très longs délais à la fin de la séquence bouclée, j'ai aussi décidé après quelques tests de dupliquer les toggles, radiogroups et autres rsliders pour qu'il soit moins fastidieux de manipuler les boucles, ainsi nous n'avons plus besoin de modifier systématiquement la boite à chiffre ''instance'' avant de lancer un enregistrement, de modifier les points de départ et d'arrivée d'une boucle etc.)
-	Module de chaînes de markov (j'ai vite compris que parfois il n'y avait aucune transition possible et donc qu'il fallait donner une valeur à laquelle retourner dans un tel cas et c'est pourquoi j'ai stocké la toute première valeur enregistrée et l'est envoyée à l'objet prob grâce à un message ''reset $1'' pour remédier à la situation.)
-	Module d'histogrammes stockés dans des tables (le résultat obtenu étant trop approximatif pour être une réelle imitation du jeu du percussionniste, j'ai décidé de développer le module de chaînes de Markov pour jouer ce rôle et d'utiliser celui d'histogrammes et de tables pour obtenir des résultats plus loin du jeu réel de l'instrumentiste, ce qui peut être très intéressant dans une optique d'échange de ''trades'' où le programme répond à l'instrumentiste sans pour autant rejouer quelque chose qui ressemble énormément.)
Fonctionnement modulaire :
-	J'ai commencé par encapsuler les modules dans des objets pour ensuite les dupliquer et utiliser une immense matrice pour faire les connexions entre ceux-ci...mais tout cela s'est vite avéré beaucoup trop compliqué, fastidieux et aucunement convivial pour l'utilisateur et c'est pourquoi j'ai plutôt décidé de faire la transition de mes objets à des versions pouvant être encapsulées dans un poly~, ce qui permet de gérer beaucoup plus efficacement la ''polyphonie de modules'' et aussi de générer le nombre voulu d'instances d'un module automatiquement (en plus de pouvoir changer ce nombre quand bon nous semble...bref, c'est beaucoup plus flexible!)
Gestion des composantes matérielles ROLI Blocks :
-	J'ai réalisé en faisant des tests que l'utilisateur pouvait être amené à faire une mauvaise utilisation des boutons, par exemple en enclenchant plusieurs toggles à la fois créant des conflits et j'ai donc élaboré un système simple réglant automatiquement les conflits de toggles en éteignant de manière intelligente les toggles qui auraient pu être oubliés.	
Système de gestion des préréglages :
-	Sélection de clients (l'objet autopattr inclue initialement tous les objets d'interface utilisateur au système de préréglages, ce qui m'a causé des problèmes puisque certains objets se doivent de ne pas être gérés par le pattrstorage, j'ai donc dû désélectionner manuellement les objets que je voulais voir être exclus du système, et ce en plusieurs étapes puisque j'ai réalisé peu à peu après divers tests quels objets il était pertinent de contrôler grâce aux préréglages et quels objets, au contraire, causaient des problèmes s'ils étaient inclus dans le pattrstorage.)
-	Ordre d'envoi (lorsqu'un préréglage est rappelé, l'ordre dans lequel les valeurs sont envoyées est plutôt erratique par défaut, ce qui m'a causé énormément de problèmes, donc j'ai dû m'assurer que les objets soient rappelés dans un ordre cohérent en utilisant le message ''clientwindow'' pour aller modifier l'ordre de priorité de rappel des différents objets au sein du patch.)
-	Modes d'interpolation (après avoir fait des tests, j'ai compris que ce n'était pas tous les objets qui pouvaient être soumis à une interpolation, puisque, par exemple, une matrice se doit de ne changer qu'au moment exact où l'on passe au prochain préréglage plutôt que d'évoluer progressivement vers le prochain était, ainsi j'ai donc dû utiliser le message ''clientwindow'' pour pouvoir aller modifier le mode d'interpolation de certains objets et le régler à ''none''.)
-	Filtrage des changements (dans son format initial, l'objet pattrstorage envoie toutes les valeurs aux objets qu'il contrôle à chaque changement de préréglage, même si les valeurs sont les mêmes d'un préréglage à l'autre, j'ai donc dû utiliser le message ''changemode 1'' pour m'assurer que les valeurs ne soient envoyées que lorsqu'elles ont effectivement changé.)
Récupération d'informations sur le jeu :
-	Tap Tempo réactif (après des tests, j'ai compris que le fait de devoir jouer toutes les subdivisions pour que la détection soit faite correctement était trop contraignant et j'ai donc élaboré un système permettant de ne pas jouer toutes les subdivisions, notamment grâce à l'utilisation de l'objet minimum et au fait d'envoyer toutes les notes jouées au ''détecteur de subdivisions''.)
-	mx.deltaverage (dans certaines situations, il est préférable que la valeur détectée soit renvoyée à chaque note, même si elle est moins précise, alors que dans d'autres cas, il est mieux d'envoyer la valeur moins souvent et d'avoir une moyenne plus représentative des dernières notes, c'est pourquoi j'ai élaboré 2 versions de l'objet mx.deltaverage : une première faisant la moyenne sur 5 notes à chaque note reçue et une deuxième faisant la moyenne des 3 dernières notes ''par paquets'', chaque fois que 3 notes ont effectivement été reçues.)
Section de sortie :
-	Quantification rythmique (en faisant des tests, j'ai réalisé que la première version de mx.timequantize utilisant l'objet onebang ne gardait pas en mémoire toutes les notes qui se devaient d'être envoyées au moment de recevoir le bang provenant d'une subdivision et n'envoyait en fait qu'une seule note à la fois, c'est pourquoi j'ai dû élaborer une deuxième version mx.timequantize_v2 utilisant un objet coll pour garder en mémoire toutes les notes à envoyer à la prochaine réception d'un bang provenant d'une subdivision.)
-	''Humanizer'' (dans sa forme originale, le jeu du programme étant beaucoup trop carré et peu naturel, j'ai décidé d'opter pour la création d'outils permettant de lui donner une touche plus humaine grâce à des variations rythmiques et dynamiques aléatoires.)
-	''Fonction de transfert MIDI'' (je me suis rendu compte qu'il n'était pas intuitif de devoir ouvrir chaque fois la table pour pouvoir la modifier et j'ai donc remplacé l'objet table par un objet itable que l'on peut modifier directement depuis le patch lui-même.